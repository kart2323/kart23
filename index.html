<!DOCTYPE html>
<html>
<head>
<title>VBA
</head>
<body>
<h1>copy </h1>
<p>copy code
<pre><code>
Option Explicit

Dim xl, wb, fso
Dim userInput, presetPath, scriptFolder, resolvedPath, folderPath, baseName, newName, newPath
Dim msg
Dim ws
Dim extList, i, fileFolder, fileNameOnly, candidate
Dim found
Dim targetSheets
Dim keepDict, arr, nameText, anyExists

' ★ここに事前指定したいファイルパス（またはファイル名）を入れる
'   空文字のままなら起動時にInputBoxで聞く
'   例1: フルパス → "C:\Users\xxx\Desktop\式付き"
'   例2: このVBSと同じフォルダのファイル → "式付き"
presetPath = ""

' ★ここに値貼り付けしたいシート名をカンマ区切りで指定
'   例: "Sheet1,Sheet2,集計"
'   空文字のままなら「全てのワークシート」が対象（削除もしない）
targetSheets = "sheet2"

' FileSystemObject を作成
Set fso = CreateObject("Scripting.FileSystemObject")

' このVBSファイルが置かれているフォルダ
scriptFolder = fso.GetParentFolderName(WScript.ScriptFullName)

' --- 入力値の決定：presetPath があればそれを使う。空なら InputBox で聞く ---
If presetPath <> "" Then
    userInput = presetPath
Else
    userInput = InputBox("Excelファイルのパス、またはこのVBSと同じフォルダにあるファイル名を入力してください。（拡張子は省略可）", "値貼り付け用Excel")
    If userInput = "" Then
        WScript.Quit
    End If
End If

found = False
resolvedPath = ""

' --- まずは userInput そのものを試す ---
If InStr(userInput, "\") = 0 And InStr(userInput, ":") = 0 Then
    ' パス区切りがない → ファイル名だけとみなして、このVBSと同じフォルダで探す
    candidate = fso.BuildPath(scriptFolder, userInput)
    If fso.FileExists(candidate) Then
        resolvedPath = candidate
        found = True
    End If
Else
    ' パス付き
    If fso.FileExists(userInput) Then
        resolvedPath = userInput
        found = True
    End If
End If

' --- まだ見つからない場合、代表的な拡張子を順番に試す ---
If Not found Then
    If InStr(userInput, "\") = 0 And InStr(userInput, ":") = 0 Then
        ' ファイル名だけ
        fileFolder   = scriptFolder
        fileNameOnly = fso.GetBaseName(userInput)  ' 拡張子があれば削る
    Else
        ' パス付き
        fileFolder   = fso.GetParentFolderName(userInput)
        fileNameOnly = fso.GetBaseName(userInput)  ' 拡張子があれば削る
    End If

    ' 試す拡張子のリスト（優先順）
    extList = Array(".xlsx", ".xlsm", ".xls", ".xlsb")

    For i = 0 To UBound(extList)
        candidate = fso.BuildPath(fileFolder, fileNameOnly & extList(i))
        If fso.FileExists(candidate) Then
            resolvedPath = candidate
            found = True
            Exit For
        End If
    Next
End If

' --- それでも見つからなければエラー ---
If Not found Or resolvedPath = "" Then
    MsgBox "ファイルが見つかりませんでした。" & vbCrLf & "入力内容: " & userInput, vbCritical, "エラー"
    WScript.Quit
End If

' --- Excel起動 ---
On Error Resume Next
Set xl = CreateObject("Excel.Application")
If Err.Number <> 0 Or (xl Is Nothing) Then
    MsgBox "Excelを起動できませんでした。原因: " & Err.Description, vbCritical, "エラー"
    WScript.Quit
End If

xl.Visible = False
xl.DisplayAlerts = False
Err.Clear

' --- 読み取り専用でブックを開く ---
Set wb = xl.Workbooks.Open(resolvedPath, False, True)
If Err.Number <> 0 Or (wb Is Nothing) Then
    MsgBox "ブックを開けませんでした。原因: " & Err.Description, vbCritical, "エラー"
    xl.Quit
    WScript.Quit
End If
Err.Clear


' --- 全シートで値貼り付け（コピー→値貼り付け方式） ---
Const xlPasteValues = -4163  ' xlPasteValues

For Each ws In wb.Worksheets
    If Not ws.UsedRange Is Nothing Then
        ws.UsedRange.Copy
        ws.UsedRange.PasteSpecial xlPasteValues
    End If
Next

xl.CutCopyMode = False

If Err.Number <> 0 Then
    MsgBox "値貼り付け中にエラーが発生しました。原因: " & Err.Description, vbCritical, "エラー"
    wb.Close False
    xl.Quit
    WScript.Quit
End If
Err.Clear

' --- シート絞り込み（targetSheets が指定されている場合のみ）---
If targetSheets <> "" Then
    Set keepDict = CreateObject("Scripting.Dictionary")
    arr = Split(targetSheets, ",")
    For i = 0 To UBound(arr)
        nameText = Trim(arr(i))
        If nameText <> "" Then
            If Not keepDict.Exists(LCase(nameText)) Then
                keepDict.Add LCase(nameText), True
            End If
        End If
    Next

    ' 少なくとも1つは存在するかチェック
    anyExists = False
    For Each ws In wb.Worksheets
        If keepDict.Exists(LCase(ws.Name)) Then
            anyExists = True
        End If
    Next

    If Not anyExists Then
        MsgBox "指定したシート名がブック内に存在しません。targetSheets の設定を確認してください。", vbCritical, "エラー"
        wb.Close False
        xl.Quit
        WScript.Quit
    End If

    ' 残さないシートを削除（後ろから順に）
    For i = wb.Worksheets.Count To 1 Step -1
        Set ws = wb.Worksheets(i)
        If Not keepDict.Exists(LCase(ws.Name)) Then
            ws.Delete
        End If
    Next
End If


' --- 同じフォルダに、必ず .xlsx（マクロなし）で保存 ---
folderPath = fso.GetParentFolderName(resolvedPath)
baseName   = fso.GetBaseName(resolvedPath)

newName = "値貼り付け_" & baseName & ".xlsx"
newPath = fso.BuildPath(folderPath, newName)

wb.SaveAs newPath, 51   ' 51 = xlOpenXMLWorkbook（マクロなし .xlsx）
If Err.Number <> 0 Then
    MsgBox "保存中にエラーが発生しました。原因: " & Err.Description, vbCritical, "エラー"
    wb.Close False
    xl.Quit
    WScript.Quit
End If

' --- 後処理 ---
wb.Close False
xl.Quit

' --- 完了メッセージ ---
MsgBox "元ファイル: " & resolvedPath & vbCrLf & "値貼り付け後のファイルを次の名前で保存しました。" & vbCrLf & newPath, vbInformation, "完了"


'================ 共分散（母分散） =========================
Public Function CovMatrix(data As Range) As Variant
    Dim n As Long, m As Long, i As Long, j As Long
    n = data.Rows.Count
    m = data.Columns.Count
    Dim arr As Variant: arr = data.Value
    Dim cov() As Double
    ReDim cov(1 To m, 1 To m)
    Dim avg_i As Double, avg_j As Double, s As Double, t As Long
    For i = 1 To m
        avg_i = Application.WorksheetFunction.Average(Application.Index(arr, 0, i))
        For j = 1 To m
            avg_j = Application.WorksheetFunction.Average(Application.Index(arr, 0, j))
            s = 0#
            For t = 1 To n
                s = s + (arr(t, i) - avg_i) * (arr(t, j) - avg_j)
            Next t
            cov(i, j) = s / n  '標本なら / (n-1)
        Next j
    Next i
    CovMatrix = cov
End Function

'================ 共通ヘルパ ===============================
Private Function Ensure2D(ByVal V As Variant) As Variant
    If TypeName(V) = "Range" Then
        Ensure2D = V.Value2
    ElseIf IsArray(V) Then
        Dim l1 As Long, u2 As Long
        On Error Resume Next
        l1 = LBound(V, 1): u2 = UBound(V, 2)
        If Err.Number <> 0 Then
            Err.Clear
            Dim L As Long, U As Long, i As Long
            L = LBound(V): U = UBound(V)
            Dim A() As Variant: ReDim A(1 To U - L + 1, 1 To 1)
            For i = L To U: A(i - L + 1, 1) = V(i): Next
            Ensure2D = A
        Else
            Ensure2D = V
        End If
        On Error GoTo 0
    Else
        Dim a1(1 To 1, 1 To 1) As Variant
        a1(1, 1) = V
        Ensure2D = a1
    End If
End Function

Private Function ToDoubleVectorV(col2D As Variant) As Variant
    Dim rL As Long, rU As Long, i As Long
    rL = LBound(col2D, 1): rU = UBound(col2D, 1)
    Dim V() As Double: ReDim V(1 To rU - rL + 1)
    For i = rL To rU
        If IsError(col2D(i, 1)) Or IsEmpty(col2D(i, 1)) Or Not IsNumeric(col2D(i, 1)) Then
            V(i - rL + 1) = 0#
        Else
            V(i - rL + 1) = CDbl(col2D(i, 1))
        End If
    Next
    ToDoubleVectorV = V
End Function

Private Function ToDoubleMatrixV(mat2D As Variant) As Variant
    Dim rL As Long, rU As Long, cL As Long, cU As Long, i As Long, j As Long
    rL = LBound(mat2D, 1): rU = UBound(mat2D, 1)
    cL = LBound(mat2D, 2): cU = UBound(mat2D, 2)
    Dim m() As Double: ReDim m(1 To rU - rL + 1, 1 To cU - cL + 1)
    For i = rL To rU
        For j = cL To cU
            If IsError(mat2D(i, j)) Or IsEmpty(mat2D(i, j)) Or Not IsNumeric(mat2D(i, j)) Then
                m(i - rL + 1, j - cL + 1) = 0#
            Else
                m(i - rL + 1, j - cL + 1) = CDbl(mat2D(i, j))
            End If
        Next j
    Next i
    ToDoubleMatrixV = m
End Function

Private Function MatVecV(m As Variant, V As Variant) As Variant
    Dim n As Long, i As Long, j As Long
    n = UBound(V)
    Dim res() As Double: ReDim res(1 To n)
    For i = 1 To n
        Dim s As Double: s = 0#
        For j = 1 To n
            s = s + m(i, j) * V(j)
        Next j
        res(i) = s
    Next i
    MatVecV = res
End Function

Private Function MaxDiagV(Mtx As Variant) As Double
    Dim n As Long, i As Long, maxVal As Double
    n = UBound(Mtx, 1)
    maxVal = Mtx(1, 1)
    For i = 2 To n
        If Mtx(i, i) > maxVal Then maxVal = Mtx(i, i)
    Next
    MaxDiagV = maxVal
End Function

Private Function VMax(A As Double, b As Double) As Double
    If A > b Then VMax = A Else VMax = b
End Function

Private Function ProjectCappedSimplexV(V As Variant, L As Variant, U As Variant) As Variant
    Dim n As Long: n = UBound(V)
    Dim w() As Double: ReDim w(1 To n)

    Dim lo As Double, hi As Double, mid As Double, s As Double
    Dim i As Long, z As Double
    lo = -1000000000000#: hi = 1000000000000#

    For i = 1 To n
        If V(i) - U(i) > lo Then lo = V(i) - U(i)
        If V(i) - L(i) < hi Then hi = V(i) - L(i)
    Next

    Dim it As Long
    For it = 1 To 60
        mid = 0.5 * (lo + hi)
        s = 0#
        For i = 1 To n
            z = V(i) - mid
            If z < L(i) Then
                z = L(i)
            ElseIf z > U(i) Then
                z = U(i)
            End If
            s = s + z
        Next
        If s > 1# Then
            lo = mid
        Else
            hi = mid
        End If
    Next

    For i = 1 To n
        z = V(i) - hi
        If z < L(i) Then
            z = L(i)
        ElseIf z > U(i) Then
            z = U(i)
        End If
        w(i) = z
    Next
    ProjectCappedSimplexV = w
End Function

Option Explicit

'=== コレスキー（下三角）分解: A=LL'。失敗時 Falseを返す ===
Private Function CholeskyDecomp(A As Variant, L As Variant) As Boolean
    Dim n As Long: n = UBound(A, 1)
    Dim i As Long, j As Long, k As Long
    Dim s As Double
    ReDim L(1 To n, 1 To n)
    On Error GoTo Fail
    For i = 1 To n
        For j = 1 To i
            s = 0#
            For k = 1 To j - 1
                s = s + L(i, k) * L(j, k)
            Next
            If i = j Then
                s = A(i, i) - s
                If s <= 0# Then CholeskyDecomp = False: Exit Function
                L(i, j) = Sqr(s)
            Else
                L(i, j) = (A(i, j) - s) / L(j, j)
            End If
        Next
    Next
    CholeskyDecomp = True
    Exit Function
Fail:
    CholeskyDecomp = False
End Function

'=== コレスキーで Ax=b を解く（前進・後退代入） ===
Private Function CholeskySolve(A As Variant, b As Variant) As Variant
    Dim n As Long: n = UBound(A, 1)
    Dim L As Variant, y() As Double, x() As Double
    Dim i As Long, k As Long, s As Double
    If Not CholeskyDecomp(A, L) Then Err.Raise 5, , "Cholesky失敗（半正定値ではない）"
    ReDim y(1 To n)
    ' 前進代入: L y = b
    For i = 1 To n
        s = b(i)
        For k = 1 To i - 1: s = s - L(i, k) * y(k): Next
        y(i) = s / L(i, i)
    Next
    ' 後退代入: L' x = y
    ReDim x(1 To n)
    For i = n To 1 Step -1
        s = y(i)
        For k = i + 1 To n: s = s - L(k, i) * x(k): Next
        x(i) = s / L(i, i)
    Next
    CholeskySolve = x
End Function

'=== {w | sum w = target, L<=w<=U} への射影（二分探索） ===
Private Sub ProjectBoxSimplexArr(w() As Double, L() As Double, U() As Double, ByVal target As Double)
    Dim n As Long: n = UBound(w)
    Dim i As Long, lo As Double, hi As Double, mid As Double, s As Double, z As Double
    lo = -1000000000000#: hi = 1000000000000#
    For i = 1 To n
        If w(i) - U(i) > lo Then lo = w(i) - U(i)
        If w(i) - L(i) < hi Then hi = w(i) - L(i)
    Next
    Dim it As Long
    For it = 1 To 60
        mid = 0.5 * (lo + hi)
        s = 0#
        For i = 1 To n
            z = w(i) - mid
            If z < L(i) Then
                z = L(i)
            ElseIf z > U(i) Then
                z = U(i)
            End If
            s = s + z
        Next
        If s > target Then lo = mid Else hi = mid
    Next
    For i = 1 To n
        z = w(i) - hi
        If z < L(i) Then
            z = L(i)
        ElseIf z > U(i) Then
            z = U(i)
        End If
        w(i) = z
    Next i
End Sub

'=== 厳密解（等式+上下限）: 逆行列/ワークシート関数 不使用／横ベクトル返し ===
' 使い方: =GMV_BOUNDED_EXACT(CovMatrix(OFFSET($X$2,0,0,125,6)), AN5:AN10, AM5:AM10)
Public Function GMV_BOUNDED_EXACT( _
    ByVal covInput As Variant, _
    ByVal L As Variant, _
    ByVal U As Variant, _
    Optional ByVal ridge As Double = 0.0000000001, _
    Optional ByVal tol As Double = 0.000000000001, _
    Optional ByVal maxIter As Long = 200 _
) As Variant
    On Error GoTo Fail

    '--- Σ 受取（Range/配列OK） ---
    Dim V As Variant
    If TypeName(covInput) = "Range" Then
        V = covInput.Value2
    Else
        V = covInput
    End If
    Dim n As Long, m As Long, i As Long, j As Long
    n = UBound(V, 1): m = UBound(V, 2)
    If n <> m Then Err.Raise 5, , "共分散は正方行列が必要です"

    Dim Sigma() As Double: ReDim Sigma(1 To n, 1 To n)
    For i = 1 To n
        For j = 1 To n
            Sigma(i, j) = CDbl(V(i, j))
        Next
    Next
    If ridge > 0# Then For i = 1 To n: Sigma(i, i) = Sigma(i, i) + ridge: Next

    '--- L/U 受取（Range/配列OK, 縦ベクトル想定） ---
    Dim LV As Variant, UV As Variant
    LV = IIf(TypeName(L) = "Range", L.Value2, L)
    UV = IIf(TypeName(U) = "Range", U.Value2, U)
    Dim Lb() As Double, Ub() As Double
    ReDim Lb(1 To n): ReDim Ub(1 To n)
    For i = 1 To n
        Lb(i) = CDbl(LV(i, 1))
        Ub(i) = CDbl(UV(i, 1))
    Next

    '--- 可行性チェック ---
    Dim sumL As Double, sumU As Double
    For i = 1 To n: sumL = sumL + Lb(i): sumU = sumU + Ub(i): Next
    If sumL > 1# + 0.000000000001 Or sumU < 1# - 0.000000000001 Then Err.Raise 5, , "不可行: SUM(L)?1?SUM(U)"

    '--- 初期点: 均等→射影 ---
    Dim w() As Double: ReDim w(1 To n)
    For i = 1 To n: w(i) = 1# / n: Next
    ProjectBoxSimplexArr w, Lb, Ub, 1#

    '--- アクティブセット ---
    Dim isB() As Boolean: ReDim isB(1 To n)
    For i = 1 To n
        If Abs(w(i) - Lb(i)) < 10 * tol Or Abs(w(i) - Ub(i)) < 10 * tol Then isB(i) = True
    Next

    Dim iter As Long
    For iter = 1 To maxIter
        Dim sumFixed As Double: sumFixed = 0#
        Dim cntF As Long: cntF = 0
        For i = 1 To n
            If isB(i) Then sumFixed = sumFixed + w(i) Else cntF = cntF + 1
        Next
        If cntF = 0 Then Exit For
        Dim targetSum As Double: targetSum = 1# - sumFixed

        ' 自由集合インデックス
        Dim F() As Long, idx As Long
        ReDim F(1 To cntF): idx = 0
        For i = 1 To n
            If Not isB(i) Then idx = idx + 1: F(idx) = i
        Next

        ' FF と 1_F を用意
        Dim FF() As Double: ReDim FF(1 To cntF, 1 To cntF)
        Dim oneF() As Double: ReDim oneF(1 To cntF)
        For i = 1 To cntF
            oneF(i) = 1#
            For j = 1 To cntF
                FF(i, j) = Sigma(F(i), F(j))
            Next
        Next

        ' y = FF^{-1} * 1_F（コレスキーで直接解く）
        Dim y As Variant: y = CholeskySolve(FF, oneF)

        ' α = target / (1_F' y)
        Dim den As Double: den = 0#
        For i = 1 To cntF: den = den + oneF(i) * y(i): Next
        If Abs(den) < 1E-18 Then Err.Raise 5, , "特異行列（ridge を上げてください）"
        Dim alpha As Double: alpha = targetSum / den

        ' w_F = α y
        For i = 1 To cntF
            w(F(i)) = alpha * y(i)
        Next

        ' 境界処理
        Dim changed As Boolean: changed = False
        For i = 1 To cntF
            Dim k As Long: k = F(i)
            If w(k) < Lb(k) - tol Then w(k) = Lb(k): isB(k) = True: changed = True
            If w(k) > Ub(k) + tol Then w(k) = Ub(k): isB(k) = True: changed = True
        Next
        If changed Then GoTo NextIter

        ' KKTチェック
        Dim Sw() As Double: ReDim Sw(1 To n)
        Dim acc As Double
        For i = 1 To n
            acc = 0#
            For j = 1 To n: acc = acc + Sigma(i, j) * w(j): Next
            Sw(i) = acc
        Next
        Dim nu As Double, cnt As Long: nu = 0#: cnt = 0
        For i = 1 To n: If Not isB(i) Then nu = nu + 2# * Sw(i): cnt = cnt + 1
        Next
        If cnt > 0 Then nu = nu / cnt Else nu = 2# * Sw(1)

        Dim violated As Long: violated = 0
        For i = 1 To n
            If isB(i) Then
                Dim gi As Double: gi = 2# * Sw(i) - nu
                If Abs(w(i) - Lb(i)) < 10 * tol Then
                    If gi < -0.0000000001 Then isB(i) = False: violated = violated + 1
                ElseIf Abs(w(i) - Ub(i)) < 10 * tol Then
                    If gi > 0.0000000001 Then isB(i) = False: violated = violated + 1
                End If
            End If
        Next
        If violated = 0 Then Exit For
NextIter:
    Next

    ' 合計=1 に微調整
    Dim sumW As Double: sumW = 0#
    For i = 1 To n: sumW = sumW + w(i): Next
    Dim delta As Double: delta = 1# - sumW
    For i = 1 To n
        If w(i) > Lb(i) + 10 * tol And w(i) < Ub(i) - 10 * tol Then
            w(i) = w(i) + delta
            Exit For
        End If
    Next

    ' 横ベクトル返し
    Dim out() As Variant: ReDim out(1 To 1, 1 To n)
    For i = 1 To n: out(1, i) = w(i): Next
    GMV_BOUNDED_EXACT = out
    Exit Function

Fail:
    GMV_BOUNDED_EXACT = CVErr(xlErrValue)
End Function

Sub RunSolverStable()

    ' 再現性のためにマルチスレッド停止
    Application.MultiThreadedCalculation.Enabled = False

    ' 強制再計算（順序を統一）
    Application.CalculateFullRebuild

    ' 初期値を強制設定
    Range("K4:P4").Value = 1 / 6

    SolverReset
    SolverOk SetCell:="$K$36", MaxMinVal:=2, _
        ByChange:="$K$4:$P$4"

    ' 制約
    SolverAdd CellRef:="$K$4:$P$4", Relation:=3, FormulaText:=1
    SolverAdd CellRef:="$K$4:$P$4", Relation:=1, FormulaText:="0"

    ' Solver オプションを明示指定
    SolverOptions Precision:=1E-12, Convergence:=1E-12, _
        MaxTime:=999, MaxIterations:=2000, _
        Scaling:=True, AssumeLinear:=False, StepThru:=False

    SolverSolve UserFinish:=True

    ' マルチスレッドを元に戻す
    Application.MultiThreadedCalculation.Enabled = True

End Sub


</code></pre>pre

</body>
</html>
