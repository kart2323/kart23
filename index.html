<!DOCTYPE html>
<html>
<head>
<title>VBA
</head>
<body>
<h1>copy </h1>
<p>copy code
<pre><code>
'====================================================
' Bloomberg + Excel 自動実行 VBS（ログ・各種フラグ付き 拡張版）
'====================================================

Option Explicit

'================ ユーザー設定 =====================
Dim jobs
jobs = Array( _
    Array("Book1.xlsm", "MacroA"), _
    Array("Book2", ""), _
    Array("C:\Path\To\Book3", "Module1.PostProcess") _
)

Dim waitShort, waitLong
waitShort = 5000     ' ステータス1 → 再チェック待ち (ms)
waitLong  = 15000    ' ステータス2 → 待ち＋再計算 (ms)

Dim maxCheckLoop
maxCheckLoop = 30     ' ステータス1/2 の最大チェック回数

' ログ出力名設定：
' ReportName = "test"           → yyyymmdd_test_正常終了/エラー有.txt
' ReportName = "ログ\test"      → yyyymmdd_test_正常終了/エラー有.txt を「ログ」フォルダ配下に
Dim ReportName
Dim ReportTagSuccess
Dim ReportTagError

ReportName       = "test"      ' ベース名（サブフォルダを含んでもよい）
ReportTagSuccess = "正常終了"  ' 正常終了時のタグ
ReportTagError   = "エラー有"  ' エラーあり時のタグ

'====================================================

Dim excelApp
Dim statusCell
Dim hadError : hadError = False
Dim results()               ' 各ブックの結果（Status, Msg）
Dim postMsgArr()            ' Range("VBA実行後表示メッセージ") の内容
Dim bloomJudgeArr()         ' Bloomberg エラー時の blg更新判定 の値
Dim interrupted : interrupted = False       ' 「以降実行しない」を選んだか

' ログ用
Dim startTime, endTime
startTime = Now()

'====================================================
' パス解決（Book, Book.xlsm, フルパス、拡張子省略すべて対応）
'====================================================

Function FileExistsEx(path)
    FileExistsEx = CreateObject("Scripting.FileSystemObject").FileExists(path)
End Function

Function TryExcelExtensions(basePath)
    Dim fso, exts, i, full
    Set fso = CreateObject("Scripting.FileSystemObject")
    exts = Array(".xlsm", ".xlsx", ".xlsb", ".xls")
    For i = 0 To UBound(exts)
        full = basePath & exts(i)
        If fso.FileExists(full) Then
            TryExcelExtensions = full
            Exit Function
        End If
    Next
    If fso.FileExists(basePath) Then
        TryExcelExtensions = basePath
    Else
        TryExcelExtensions = ""
    End If
End Function

Function ResolveExcelPath(rawPath)
    Dim fso, scriptDir
    Dim hasSep, p, basePath, dotPos, sepPos, full

    Set fso = CreateObject("Scripting.FileSystemObject")
    scriptDir = fso.GetParentFolderName(WScript.ScriptFullName)

    p = Trim(rawPath)
    If p = "" Then
        ResolveExcelPath = ""
        Exit Function
    End If

    hasSep = (InStr(p, "\") > 0) Or (InStr(p, ":") > 0)

    If hasSep Then
        If fso.FileExists(p) Then
            ResolveExcelPath = p
            Exit Function
        End If

        sepPos = InStrRev(p, "\")
        basePath = p
        dotPos = InStrRev(basePath, ".")
        If dotPos > sepPos Then
            basePath = Left(basePath, dotPos - 1)
        End If

        ResolveExcelPath = TryExcelExtensions(basePath)
    Else
        full = fso.BuildPath(scriptDir, p)
        If fso.FileExists(full) Then
            ResolveExcelPath = full
            Exit Function
        End If

        basePath = p
        dotPos = InStrRev(basePath, ".")
        If dotPos > 0 Then
            basePath = Left(basePath, dotPos - 1)
        End If

        ResolveExcelPath = TryExcelExtensions(fso.BuildPath(scriptDir, basePath))
    End If
End Function

'====================================================
' Named Range を安全に探すヘルパ（ブック/シートスコープ両対応）
'====================================================

Function GetNamedCell(wb, nmStr)
    Dim nm
    On Error Resume Next
    Set GetNamedCell = Nothing

    ' まずダイレクトに試す
    Set GetNamedCell = wb.Names(nmStr).RefersToRange
    If Err.Number = 0 And Not GetNamedCell Is Nothing Then
        On Error GoTo 0
        Exit Function
    End If
    Err.Clear

    ' 見つからなければ全 Names を総当たり
    For Each nm In wb.Names
        If InStr(1, nm.Name, nmStr, 1) > 0 Then
            Set GetNamedCell = nm.RefersToRange
            Exit For
        End If
    Next
    On Error GoTo 0
End Function

'====================================================
' Bloomberg ステータス取得
'====================================================

Function GetStatus()
    On Error Resume Next
    Dim v
    v = statusCell.Value
    If Err.Number <> 0 Then
        Err.Clear
        GetStatus = 3
        Exit Function
    End If
    If IsNumeric(v) Then
        GetStatus = CLng(v)
    Else
        GetStatus = 3
    End If
End Function

'====================================================
' 単一ブック処理
'====================================================

Sub ProcessWorkbook(xlApp, filePath, macroName, index)
    Dim wb, s, i, finalStatus
    Dim hasJudge
    Dim shell
    Dim runningCell, postCheckCell, postMsgCell   ' ①～③用
    Dim bjv

    Set shell = CreateObject("WScript.Shell")

    '--- ブックオープン ---
    On Error Resume Next
    Set wb = xlApp.Workbooks.Open(filePath)
    If Err.Number <> 0 Then
        results(index) = Array("ERROR", "ブックを開けません：" & Err.Description)
        hadError = True
        Err.Clear
        AskContinueOrExit index, filePath, "ブックを開けません"
        Exit Sub
    End If
    On Error GoTo 0

    '--- Named Range の取得 ---
    Set statusCell     = GetNamedCell(wb, "blg更新判定")
    Set runningCell    = GetNamedCell(wb, "VBA自動実行中")
    Set postCheckCell  = GetNamedCell(wb, "VBA実行後チェック")
    Set postMsgCell    = GetNamedCell(wb, "VBA実行後表示メッセージ")

    hasJudge = Not (statusCell Is Nothing)

    ' 計算モード自動
    xlApp.Calculation = -4105   ' xlCalculationAutomatic

    ' 最初の全再計算
    xlApp.CalculateFullRebuild
    WScript.Sleep waitShort

    ' ===== blg更新判定 が無い場合は Bloomberg 判定スキップ =====
    If Not hasJudge Then

        ExecuteMacroIfNeeded xlApp, macroName, index, filePath, runningCell

        '--- VBA実行後チェック（0=正常 / 1=エラー / 2=留意点あり / 3=留意点あり(サイレント)）---
        If Not postCheckCell Is Nothing Then
            Dim vPost, postStatus
            postStatus = 0
            On Error Resume Next
            vPost = postCheckCell.Value
            If Err.Number = 0 And IsNumeric(vPost) Then
                postStatus = CLng(vPost)
            End If
            Err.Clear
            On Error GoTo 0

            If postStatus = 1 Then
                HandlePostVBAError wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            ElseIf postStatus = 2 Then
                HandlePostVBAWarning wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            ElseIf postStatus = 3 Then
                HandlePostVBAWarningSilent wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            End If
        End If

        ' 正常パス：保存・クローズのみ（フラグ操作は ExecuteMacroIfNeeded/Handle系で実施）
        wb.Save
        wb.Close False
        results(index) = Array("OK", "判定なし（blg更新判定 なし）")
        Exit Sub
    End If

    '================ Bloomberg 判定ループ ==================
    finalStatus = 3

    For i = 1 To maxCheckLoop
        s = GetStatus()
        finalStatus = s

        Select Case s
            Case 0
                Exit For

            Case 1
                WScript.Sleep waitShort

            Case 2
                WScript.Sleep waitLong
                xlApp.CalculateFull

            Case 3
                ' Bloomberg 未接続/エラー
                bjv = ""
                If Not statusCell Is Nothing Then
                    On Error Resume Next
                    bjv = statusCell.Value
                    On Error GoTo 0
                End If
                If bjv <> "" Then
                    bloomJudgeArr(index) = bjv
                End If

                results(index) = Array("ERROR", "Bloomberg 未接続/エラー")
                hadError = True

                wb.Close False
                AskContinueOrExit index, filePath, "Bloomberg 未接続/エラー"
                Exit Sub

            Case Else
                results(index) = Array("ERROR", "想定外ステータス: " & s)
                hadError = True

                wb.Close False
                AskContinueOrExit index, filePath, "想定外ステータス"
                Exit Sub
        End Select
    Next

    '================ 最終処理（finalStatus=0 の時） ==================
    If finalStatus = 0 Then
        ' マクロ実行（失敗時は中で AskContinueOrExit を呼んでいる）
        If ExecuteMacroIfNeeded(xlApp, macroName, index, filePath, runningCell) = False Then
            wb.Close False
            Exit Sub
        End If

        '--- VBA実行後チェック（0=正常 / 1=エラー / 2=留意点あり / 3=留意点あり(サイレント)）---
        If Not postCheckCell Is Nothing Then
            Dim vPost2, postStatus2
            postStatus2 = 0
            On Error Resume Next
            vPost2 = postCheckCell.Value
            If Err.Number = 0 And IsNumeric(vPost2) Then
                postStatus2 = CLng(vPost2)
            End If
            Err.Clear
            On Error GoTo 0

            If postStatus2 = 1 Then
                HandlePostVBAError wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            ElseIf postStatus2 = 2 Then
                HandlePostVBAWarning wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            ElseIf postStatus2 = 3 Then
                HandlePostVBAWarningSilent wb, index, filePath, postMsgCell, runningCell
                Exit Sub
            End If
        End If

        ' 正常パス：保存・クローズのみ
        wb.Save
        wb.Close False
        results(index) = Array("OK", "")
    Else
        results(index) = Array("ERROR", "ステータス0にならず（finalStatus=" & finalStatus & "）")
        hadError = True

        wb.Close False
        AskContinueOrExit index, filePath, "Bloomberg更新失敗（最終ステータス≠0）"
        Exit Sub
    End If
End Sub

'====================================================
' マクロ実行（VBA自動実行中フラグをここで一括管理）
'====================================================

Function ExecuteMacroIfNeeded(xlApp, macroName, index, filePath, runningCell)
    ExecuteMacroIfNeeded = True

    ' マクロ名が空なら何もしない（フラグも触らない）
    If macroName = "" Then
        Exit Function
    End If

    On Error Resume Next

    ' --- マクロ実行直前にフラグを 1 にする ---
    If Not runningCell Is Nothing Then
        runningCell.Value = 1
    End If
    Err.Clear

    ' --- マクロ実行 ---
    xlApp.Run macroName

    If Err.Number <> 0 Then
        ' エラー発生時：必ず 0 に戻す
        If Not runningCell Is Nothing Then
            On Error Resume Next
            runningCell.Value = 0
            On Error GoTo 0
        End If

        results(index) = Array("ERROR", "マクロ実行失敗：" & Err.Description)
        hadError = True
        Err.Clear
        ExecuteMacroIfNeeded = False
        On Error GoTo 0
        AskContinueOrExit index, filePath, "マクロ実行失敗"
        Exit Function
    End If

    ' --- 正常終了時も必ず 0 に戻す ---
    If Not runningCell Is Nothing Then
        On Error Resume Next
        runningCell.Value = 0
        On Error GoTo 0
    End If

    On Error GoTo 0
End Function

'====================================================
' VBA実行後チェック =1 のとき（エラー）
'====================================================

Sub HandlePostVBAError(wb, index, filePath, postMsgCell, runningCell)
    Dim shell
    Dim detailMsg, baseMsg, extra
    Dim retSave, retCont, nextIndex

    Set shell = CreateObject("WScript.Shell")

    extra = ""
    If Not postMsgCell Is Nothing Then
        On Error Resume Next
        extra = CStr(postMsgCell.Value)
        On Error GoTo 0
        If Trim(extra) <> "" Then
            postMsgArr(index) = extra
        End If
    End If

    If Trim(extra) <> "" Then
        detailMsg = vbCrLf & "【詳細】" & extra
    Else
        detailMsg = ""
    End If

    baseMsg = (index + 1) & "番目のブック「" & filePath & "」でVBA実行後にエラー発生。" & detailMsg

    ' 1) このブックを保存しますか？
    retSave = shell.Popup(baseMsg & vbCrLf & vbCrLf & "このブックを保存しますか？", _
                          0, "VBA実行後エラー", 4 + 48)
    If retSave = 6 Then ' Yes
        On Error Resume Next
        wb.Save
        On Error GoTo 0
    End If

    ' 2) 次以降を継続しますか？
    nextIndex = index + 2
    retCont = shell.Popup("続けて " & nextIndex & "番目以降のブックを実行しますか？", _
                          0, "処理継続確認", 4 + 32)
    If retCont = 7 Then ' No
        interrupted = True
    End If

    ' フラグを0に戻す（念のため）
    If Not runningCell Is Nothing Then
        On Error Resume Next
        runningCell.Value = 0
        On Error GoTo 0
    End If

    wb.Close False

    results(index) = Array("ERROR", "VBA実行後エラー")
    hadError = True
End Sub

'====================================================
' 2：VBA実行後チェック =2 のとき（留意点あり＝OK＋コメント、要確認）
'====================================================

Sub HandlePostVBAWarning(wb, index, filePath, postMsgCell, runningCell)
    Dim shell
    Dim extra, baseMsg, detailMsg
    Dim retSave, retCont, nextIndex

    Set shell = CreateObject("WScript.Shell")

    extra = ""
    If Not postMsgCell Is Nothing Then
        On Error Resume Next
        extra = CStr(postMsgCell.Value)
        On Error GoTo 0
        If Trim(extra) <> "" Then
            postMsgArr(index) = extra
        End If
    End If

    If Trim(extra) <> "" Then
        detailMsg = vbCrLf & "【留意点】" & extra
    Else
        detailMsg = ""
    End If

    baseMsg = (index + 1) & "番目のブック「" & filePath & "」で留意点あり。" & detailMsg

    ' 1) このブックを保存しますか？
    retSave = shell.Popup(baseMsg & vbCrLf & vbCrLf & "このブックを保存しますか？", _
                          0, "留意点あり", 4 + 48)
    If retSave = 6 Then ' Yes
        On Error Resume Next
        wb.Save
        On Error GoTo 0
    End If

    ' 2) 次以降を継続しますか？
    nextIndex = index + 2
    retCont = shell.Popup("続けて " & nextIndex & "番目以降のブックを実行しますか？", _
                          0, "処理継続確認", 4 + 32)
    If retCont = 7 Then ' No
        interrupted = True
    End If

    ' フラグを0に戻す（念のため）
    If Not runningCell Is Nothing Then
        On Error Resume Next
        runningCell.Value = 0
        On Error GoTo 0
    End If

    wb.Close False

    ' 正常終了扱い（コメント付き）
    results(index) = Array("OK", "留意点あり")
End Sub

'====================================================
' 3：VBA実行後チェック =3 のとき（留意点あり＝OK＋コメント、途中確認無し）
'====================================================

Sub HandlePostVBAWarningSilent(wb, index, filePath, postMsgCell, runningCell)
    Dim extra

    extra = ""
    If Not postMsgCell Is Nothing Then
        On Error Resume Next
        extra = CStr(postMsgCell.Value)
        On Error GoTo 0
        If Trim(extra) <> "" Then
            postMsgArr(index) = extra
        End If
    End If

    ' フラグを0に戻す（念のため）
    If Not runningCell Is Nothing Then
        On Error Resume Next
        runningCell.Value = 0
        On Error GoTo 0
    End If

    ' サイレントに保存して閉じる（途中確認なし）
    On Error Resume Next
    wb.Save
    wb.Close False
    On Error GoTo 0

    ' 正常終了扱い（コメント付き・サイレント）
    results(index) = Array("OK", "留意点あり（自動）")
End Sub

'====================================================
' エラー時 Yes/No ポップアップ（Bloomberg系・マクロ系など）
'====================================================

Sub AskContinueOrExit(index, filePath, msg)
    Dim shell
    Dim nextIndex
    Dim ret

    Set shell = CreateObject("WScript.Shell")
    nextIndex = index + 2  ' 人間向け 1始まり

    ret = shell.Popup( _
        (index + 1) & "番目のブック「" & filePath & "」でエラー発生：" & vbCrLf & _
        "【" & msg & "】" & vbCrLf & vbCrLf & _
        nextIndex & "番目以降のブックの実行を継続しますか？", _
        0, "エラー発生", 4 + 32)

    If ret = 7 Then
        interrupted = True
    End If
End Sub

'====================================================
' メイン処理
'====================================================

Dim resolvedPath, macroName, rawPath
Dim i

ReDim results(UBound(jobs))
ReDim postMsgArr(UBound(jobs))
ReDim bloomJudgeArr(UBound(jobs))

Set excelApp = CreateObject("Excel.Application")
excelApp.Visible = False
excelApp.DisplayAlerts = False
excelApp.EnableEvents = False

For i = 0 To UBound(jobs)

    If interrupted Then
        results(i) = Array("SKIPPED", "前のブックでエラーのため実行せず")
    Else
        rawPath   = jobs(i)(0)
        macroName = jobs(i)(1)
        resolvedPath = ResolveExcelPath(rawPath)

        If resolvedPath = "" Then
            results(i) = Array("ERROR", "ファイル見つからず：" & rawPath)
            hadError = True
            AskContinueOrExit i, rawPath, "ファイルが見つからない"
        Else
            ProcessWorkbook excelApp, resolvedPath, macroName, i
        End If
    End If

Next

excelApp.Quit

'====================================================
' 最終レポート生成
'====================================================

Dim report, okCount, errCount, skipCount
Dim okWithCommentCount, bloomErrCount, vbaPostErrCount, otherErrCount
okCount = 0
errCount = 0
skipCount = 0
okWithCommentCount = 0
bloomErrCount = 0
vbaPostErrCount = 0
otherErrCount = 0

report = "=== 実行レポート ===" & vbCrLf & vbCrLf
report = report & "実行VBS：" & WScript.ScriptFullName & vbCrLf
report = report & "対象ブック数：" & (UBound(jobs) + 1) & vbCrLf & vbCrLf

report = report & "■ 各ブックの結果" & vbCrLf

For i = 0 To UBound(results)
    Dim status, msg
    status = results(i)(0)
    msg    = results(i)(1)

    report = report & (i + 1) & "番目（" & jobs(i)(0) & "）： " & status
    If msg <> "" Then
        report = report & " … " & msg
    End If
    report = report & vbCrLf

    If status = "OK" Then
        okCount = okCount + 1
        If Not IsEmpty(postMsgArr(i)) Then
            If Trim(CStr(postMsgArr(i))) <> "" Then
                okWithCommentCount = okWithCommentCount + 1
            End If
        End If
    ElseIf status = "ERROR" Then
        errCount = errCount + 1
        If InStr(msg, "Bloomberg 未接続/エラー") > 0 Then
            bloomErrCount = bloomErrCount + 1
        ElseIf InStr(msg, "VBA実行後エラー") > 0 Then
            vbaPostErrCount = vbaPostErrCount + 1
        Else
            otherErrCount = otherErrCount + 1
        End If
    ElseIf status = "SKIPPED" Then
        skipCount = skipCount + 1
    End If
Next

report = report & vbCrLf
report = report & "正常終了：" & okCount & "（うちコメントつき：" & okWithCommentCount & "）" & vbCrLf
report = report & "Bloomberg 未接続/エラー：" & bloomErrCount & vbCrLf
report = report & "VBA実行後エラー：" & vbaPostErrCount & vbCrLf
report = report & "実行せず：" & skipCount & vbCrLf
If otherErrCount > 0 Then
    report = report & "その他エラー：" & otherErrCount & vbCrLf
End If

'====================================================
' ■コメント セクション生成
'====================================================

Dim commentReport
commentReport = ""

If okWithCommentCount > 0 Or bloomErrCount > 0 Or vbaPostErrCount > 0 Or skipCount > 0 Then
    commentReport = commentReport & vbCrLf & "■コメント" & vbCrLf & vbCrLf

    ' ＜正常終了＞（コメント付きのみ）
    If okWithCommentCount > 0 Then
        commentReport = commentReport & "＜正常終了＞" & vbCrLf
        For i = 0 To UBound(results)
            If results(i)(0) = "OK" Then
                If Not IsEmpty(postMsgArr(i)) Then
                    If Trim(CStr(postMsgArr(i))) <> "" Then
                        commentReport = commentReport & (i + 1) & "番目（" & jobs(i)(0) & "）： " & CStr(postMsgArr(i)) & vbCrLf
                    End If
                End If
            End If
        Next
        commentReport = commentReport & vbCrLf
    End If

    ' ＜Bloomberg未接続/エラー＞
    If bloomErrCount > 0 Then
        commentReport = commentReport & "＜Bloomberg未接続/エラー＞" & vbCrLf
        For i = 0 To UBound(results)
            If results(i)(0) = "ERROR" Then
                If InStr(results(i)(1), "Bloomberg 未接続/エラー") > 0 Then
                    Dim lineB, bj
                    lineB = (i + 1) & "番目（" & jobs(i)(0) & "）："
                    bj = ""
                    If Not IsEmpty(bloomJudgeArr(i)) Then
                        bj = CStr(bloomJudgeArr(i))
                    End If
                    If Trim(bj) <> "" Then
                        lineB = lineB & "blg更新判定" & bj & " / "
                    End If
                    lineB = lineB & "Bloomberg未接続、またはデータが最新化されていない可能性"
                    commentReport = commentReport & lineB & vbCrLf
                End If
            End If
        Next
        commentReport = commentReport & vbCrLf
    End If

    ' ＜VBA実行後エラー＞
    If vbaPostErrCount > 0 Then
        commentReport = commentReport & "＜VBA実行後エラー＞" & vbCrLf
        For i = 0 To UBound(results)
            If results(i)(0) = "ERROR" Then
                If InStr(results(i)(1), "VBA実行後エラー") > 0 Then
                    Dim lineE, cmt
                    lineE = (i + 1) & "番目（" & jobs(i)(0) & "）："
                    cmt = ""
                    If Not IsEmpty(postMsgArr(i)) Then
                        cmt = CStr(postMsgArr(i))
                    End If
                    If Trim(cmt) <> "" Then
                        lineE = lineE & cmt
                    Else
                        lineE = lineE & "（コメントなし）"
                    End If
                    commentReport = commentReport & lineE & vbCrLf
                End If
            End If
        Next
        commentReport = commentReport & vbCrLf
    End If

    ' ＜実行せず＞
    If skipCount > 0 Then
        commentReport = commentReport & "＜実行せず＞" & vbCrLf
        For i = 0 To UBound(results)
            If results(i)(0) = "SKIPPED" Then
                commentReport = commentReport & (i + 1) & "番目（" & jobs(i)(0) & "）" & vbCrLf
            End If
        Next
        commentReport = commentReport & vbCrLf
    End If
End If

report = report & commentReport

'====================================================
' ログファイル出力（ReportName が空でない場合のみ）
' yyyymmdd_[ReportNameベース]_正常終了/エラー有.txt
'====================================================

Dim fso, scriptName, scriptDir, logPath, logText, logFile
Set fso = CreateObject("Scripting.FileSystemObject")

If Trim(ReportName) <> "" Then
    scriptName = fso.GetBaseName(WScript.ScriptName)
    scriptDir  = fso.GetParentFolderName(WScript.ScriptFullName)

    ' ReportName からベースパスを作る（サブフォルダ対応）
    ' 例: "test" → scriptDir\test
    '     "ログ\test" → scriptDir\ログ\test
    Dim basePath, outDir, basePart
    basePath = fso.BuildPath(scriptDir, ReportName)

    outDir   = fso.GetParentFolderName(basePath)
    If outDir = "" Then outDir = scriptDir
    basePart = fso.GetBaseName(basePath)

    ' 出力フォルダが無ければ作成（1階層想定）
    If Not fso.FolderExists(outDir) Then
        On Error Resume Next
        fso.CreateFolder(outDir)
        On Error GoTo 0
    End If

    ' 日付文字列
    Dim dateStr, tagStr
    dateStr = Year(Date) & Right("0" & Month(Date), 2) & Right("0" & Day(Date), 2)

    If errCount > 0 Then
        tagStr = ReportTagError
    Else
        tagStr = ReportTagSuccess
    End If

    ' 例: 20251209_test_正常終了.txt
    Dim logFileName
    logFileName = dateStr & "_" & basePart & "_" & tagStr & ".txt"
    logPath = fso.BuildPath(outDir, logFileName)

    endTime = Now()
    Dim duration
    duration = DateDiff("s", startTime, endTime)

    logText = "=== Bloomberg & VBA 自動実行ログ ===" & vbCrLf & vbCrLf
    logText = logText & "実行開始: " & CStr(startTime) & vbCrLf
    logText = logText & "実行終了: " & CStr(endTime) & vbCrLf
    logText = logText & "処理時間: " & duration & " 秒" & vbCrLf & vbCrLf
    logText = logText & report

    Set logFile = fso.CreateTextFile(logPath, True, True)  ' 上書き, Unicode
    logFile.Write logText
    logFile.Close
End If

'====================================================
' 最終ポップアップ & 終了コード
'====================================================

CreateObject("WScript.Shell").Popup report, 0, "最終レポート", 64

If errCount > 0 Then
    WScript.Quit 1
Else
    WScript.Quit 0
End If

次
'--- ブックオープン（リンク自動更新） ---
On Error Resume Next
' 第2引数 UpdateLinks:=3 で外部リンクをすべて更新
Set wb = xlApp.Workbooks.Open(filePath, 3)
If Err.Number <> 0 Then
    results(index) = Array("ERROR", "ブックを開けません：" & Err.Description)
    hadError = True
    Err.Clear
    AskContinueOrExit index, filePath, "ブックを開けません"
    Exit Sub
End If
On Error GoTo 0
次
excelApp.AskToUpdateLinks = False
    
次のコード
'====================================================
' Bloomberg 関数入り Excel を複数ファイル順番に処理する VBS
'
' 各ブックごとの処理：
'   1) 開く
'   2) Excel 計算モードを自動に設定
'   3) CalculateFullRebuild で一度だけフル再計算
'   4) Named Range "blg更新判定" の有無で分岐
'      - 無い：判定スキップ → マクロA（指定あれば）実行 → 保存 → 閉じる
'      - 有る：ステータス監視ループ
'         * 0：OK → マクロA（指定あれば）実行 → 保存 → 閉じる
'         * 1：更新中 → waitShort 待って再度 GetStatus（再計算なし）
'         * 2：最新でない → waitLong 待ってから CalculateFull → 再度判定
'         * 3 / その他：エラー扱い → 保存せず閉じる
'
'   ※ この VBS は Bloomberg 専用マクロ呼び出しは一切せず、
'      「再計算による更新＋blg更新判定セルのロジック」に完全依存する設計。
'====================================================

Option Explicit

'================ ユーザー設定ゾーン =====================

' ▼ 処理したい Excelファイル と「成功時に実行するマクロ名」のセット
'   形式: Array( Array("ファイルパス1", "マクロ名1"), _
'                Array("ファイルパス2", ""), _
'                Array("ファイルパス3", "Module1.Cleanup") )
'   マクロ名が "" の場合、そのブックではマクロ実行をスキップ。
Dim jobs
jobs = Array( _
    Array("C:\Path\To\Book1.xlsm", "MacroA"), _
    Array("C:\Path\To\Book2.xlsm", ""), _
    Array("C:\Path\To\Book3.xlsm", "Module1.PostProcess") _
)

' ▼ 待ち時間（ミリ秒）
Dim waitShort, waitLong
waitShort = 5000   ' ステータス1のときの再チェック待ち (5秒)
waitLong  = 15000  ' ステータス2のときの待ち＋再計算 (15秒)

' ▼ ステータス監視の最大ループ回数
Dim maxCheckLoop
maxCheckLoop = 30   ' 1/2 状態でぐるぐるしすぎないための上限

'====================================================

Dim excelApp
Dim statusCell
Dim hadError
hadError = False

'================ ステータス取得関数 ========================
' Named Range "blg更新判定" からステータス(0/1/2/3)を Long で取得
' 読めなかった場合は 3 を返す（エラー扱い）
Function GetStatus()
    On Error Resume Next
    Dim v
    v = statusCell.Value

    If Err.Number <> 0 Then
        Err.Clear
        GetStatus = 3   ' エラー → 異常扱い
        Exit Function
    End If

    If IsNumeric(v) Then
        GetStatus = CLng(v)
    Else
        GetStatus = 3   ' 数値でない → 異常扱い
    End If
End Function

'================ 単一ブック処理 ========================
Sub ProcessWorkbook(ByVal xlApp, ByVal filePath, ByVal macroName)
    Dim wb
    Dim s, i
    Dim finalStatus
    Dim hasJudge As Boolean

    On Error Resume Next
    Set wb = xlApp.Workbooks.Open(filePath)
    If Err.Number <> 0 Then
        WScript.Echo "[ERROR] ブックを開けませんでした: " & filePath & " / " & Err.Description
        Err.Clear
        hadError = True
        Exit Sub
    End If
    On Error GoTo 0

    WScript.Echo ">> 開始: " & filePath

    '==== blg更新判定 Named Range の存在チェック ====
    On Error Resume Next
    Set statusCell = wb.Names("blg更新判定").RefersToRange
    If Err.Number <> 0 Then
        ' ★ Named Range がない → 判定スキップモード
        hasJudge = False
        Err.Clear
    Else
        hasJudge = True
    End If
    On Error GoTo 0

    '------ Excel計算モードを自動(Automatic)に ------
    ' xlCalculationAutomatic = -4105
    xlApp.Calculation = -4105

    '------ 最初の再計算（これを1回だけ） ------
    xlApp.CalculateFullRebuild
    WScript.Sleep waitShort

    '===== 判定スキップモードの場合 =====
    If Not hasJudge Then
        WScript.Echo "  [INFO] blg更新判定 が無いため、判定をスキップします。"

        ' マクロ名が指定されていれば実行
        If macroName <> "" Then
            On Error Resume Next
            WScript.Echo "  [INFO] マクロ実行（判定スキップ）: " & macroName
            xlApp.Run macroName
            If Err.Number <> 0 Then
                WScript.Echo "  [ERROR] マクロ実行に失敗: " & macroName & " / " & Err.Description
                Err.Clear
                hadError = True
            End If
            On Error GoTo 0
        End If

        ' 保存して終了
        wb.Save
        WScript.Echo "  [INFO] 保存完了（判定スキップ）: " & filePath
        wb.Close False
        WScript.Echo ">> 終了（判定スキップ）: " & filePath
        Exit Sub
    End If

    '================= ここから通常のステータス判定 ===============
    finalStatus = 3 ' デフォルトは異常扱い

    For i = 1 To maxCheckLoop

        s = GetStatus()
        finalStatus = s

        Select Case s
            Case 0
                WScript.Echo "  [INFO] Bloomberg 更新完了（ステータス0）"
                Exit For

            Case 1
                ' 更新中：ただ待つだけ。再計算はしない
                WScript.Echo "  [INFO] 更新処理中（ステータス1）。再チェック待機 " & (waitShort / 1000) & " 秒。"
                WScript.Sleep waitShort

            Case 2
                ' 最新でない：待ってから再計算して再チェック
                WScript.Echo "  [INFO] データが最新でない可能性（ステータス2）。待機 " & (waitLong / 1000) & " 秒後に再計算。"
                WScript.Sleep waitLong
                xlApp.CalculateFull  ' ★ここだけ再計算を許可（必要最小限）

            Case 3
                WScript.Echo "  [ERROR] ステータス3：未接続/エラー。保存せず終了します。"
                hadError = True
                Exit For

            Case Else
                WScript.Echo "  [ERROR] 想定外ステータス: " & s & "。保存せず終了します。"
                hadError = True
                Exit For
        End Select

    Next

    '===== 最終ステータスで結果処理 =====
    If finalStatus = 0 Then

        ' マクロ実行
        If macroName <> "" Then
            On Error Resume Next
            WScript.Echo "  [INFO] マクロ実行: " & macroName
            xlApp.Run macroName
            If Err.Number <> 0 Then
                WScript.Echo "  [ERROR] マクロ実行失敗: " & macroName & " / " & Err.Description
                Err.Clear
                hadError = True
            End If
            On Error GoTo 0
        End If

        wb.Save
        WScript.Echo "  [INFO] 保存完了: " & filePath
        wb.Close False

    Else
        ' ステータス0以外：保存せず閉じる
        WScript.Echo "  [WARN] ステータス0以外(" & finalStatus & ")のため、保存せずクローズ: " & filePath
        wb.Close False
    End If

    WScript.Echo ">> 終了: " & filePath
End Sub

'================ メイン ========================

On Error Resume Next
Set excelApp = CreateObject("Excel.Application")
If Err.Number <> 0 Then
    WScript.Echo "[FATAL] Excel を起動できませんでした: " & Err.Description
    WScript.Quit 1
End If
On Error GoTo 0

' 自動バッチ用設定（画面非表示・アラート抑制）
excelApp.Visible = False
excelApp.DisplayAlerts = False
excelApp.EnableEvents = False

Dim job, filePath, macroName
For Each job In jobs
    filePath = job(0)
    macroName = job(1)
    ProcessWorkbook excelApp, filePath, macroName
Next

excelApp.Quit
Set excelApp = Nothing

If hadError Then
    WScript.Echo "=== 終了（エラーあり）==="
    WScript.Quit 1
Else
    WScript.Echo "=== 正常終了（全ブックOK or ステータス0以外は非保存クローズ）==="
    WScript.Quit 0
End If

値貼り付けまくろ
Option Explicit

Dim xl, wb, fso
Dim userInput, presetPath, scriptFolder, resolvedPath, folderPath, baseName, newName, newPath
Dim msg
Dim ws
Dim extList, i, fileFolder, fileNameOnly, candidate
Dim found
Dim targetSheets
Dim keepDict, arr, nameText, anyExists

' ★ここに事前指定したいファイルパス（またはファイル名）を入れる
'   空文字のままなら起動時にInputBoxで聞く
'   例1: フルパス → "C:\Users\xxx\Desktop\式付き"
'   例2: このVBSと同じフォルダのファイル → "式付き"
presetPath = ""

' ★ここに値貼り付けしたいシート名をカンマ区切りで指定
'   例: "Sheet1,Sheet2,集計"
'   空文字のままなら「全てのワークシート」が対象（削除もしない）
targetSheets = "sheet2"

' FileSystemObject を作成
Set fso = CreateObject("Scripting.FileSystemObject")

' このVBSファイルが置かれているフォルダ
scriptFolder = fso.GetParentFolderName(WScript.ScriptFullName)

' --- 入力値の決定：presetPath があればそれを使う。空なら InputBox で聞く ---
If presetPath <> "" Then
    userInput = presetPath
Else
    userInput = InputBox("Excelファイルのパス、またはこのVBSと同じフォルダにあるファイル名を入力してください。（拡張子は省略可）", "値貼り付け用Excel")
    If userInput = "" Then
        WScript.Quit
    End If
End If

found = False
resolvedPath = ""

' --- まずは userInput そのものを試す ---
If InStr(userInput, "\") = 0 And InStr(userInput, ":") = 0 Then
    ' パス区切りがない → ファイル名だけとみなして、このVBSと同じフォルダで探す
    candidate = fso.BuildPath(scriptFolder, userInput)
    If fso.FileExists(candidate) Then
        resolvedPath = candidate
        found = True
    End If
Else
    ' パス付き
    If fso.FileExists(userInput) Then
        resolvedPath = userInput
        found = True
    End If
End If

' --- まだ見つからない場合、代表的な拡張子を順番に試す ---
If Not found Then
    If InStr(userInput, "\") = 0 And InStr(userInput, ":") = 0 Then
        ' ファイル名だけ
        fileFolder   = scriptFolder
        fileNameOnly = fso.GetBaseName(userInput)  ' 拡張子があれば削る
    Else
        ' パス付き
        fileFolder   = fso.GetParentFolderName(userInput)
        fileNameOnly = fso.GetBaseName(userInput)  ' 拡張子があれば削る
    End If

    ' 試す拡張子のリスト（優先順）
    extList = Array(".xlsx", ".xlsm", ".xls", ".xlsb")

    For i = 0 To UBound(extList)
        candidate = fso.BuildPath(fileFolder, fileNameOnly & extList(i))
        If fso.FileExists(candidate) Then
            resolvedPath = candidate
            found = True
            Exit For
        End If
    Next
End If

' --- それでも見つからなければエラー ---
If Not found Or resolvedPath = "" Then
    MsgBox "ファイルが見つかりませんでした。" & vbCrLf & "入力内容: " & userInput, vbCritical, "エラー"
    WScript.Quit
End If

' --- Excel起動 ---
On Error Resume Next
Set xl = CreateObject("Excel.Application")
If Err.Number <> 0 Or (xl Is Nothing) Then
    MsgBox "Excelを起動できませんでした。原因: " & Err.Description, vbCritical, "エラー"
    WScript.Quit
End If

xl.Visible = False
xl.DisplayAlerts = False
Err.Clear

' --- 読み取り専用でブックを開く ---
Set wb = xl.Workbooks.Open(resolvedPath, False, True)
If Err.Number <> 0 Or (wb Is Nothing) Then
    MsgBox "ブックを開けませんでした。原因: " & Err.Description, vbCritical, "エラー"
    xl.Quit
    WScript.Quit
End If
Err.Clear


' --- 全シートで値貼り付け（コピー→値貼り付け方式） ---
Const xlPasteValues = -4163  ' xlPasteValues

For Each ws In wb.Worksheets
    If Not ws.UsedRange Is Nothing Then
        ws.UsedRange.Copy
        ws.UsedRange.PasteSpecial xlPasteValues
    End If
Next

xl.CutCopyMode = False

If Err.Number <> 0 Then
    MsgBox "値貼り付け中にエラーが発生しました。原因: " & Err.Description, vbCritical, "エラー"
    wb.Close False
    xl.Quit
    WScript.Quit
End If
Err.Clear

' --- シート絞り込み（targetSheets が指定されている場合のみ）---
If targetSheets <> "" Then
    Set keepDict = CreateObject("Scripting.Dictionary")
    arr = Split(targetSheets, ",")
    For i = 0 To UBound(arr)
        nameText = Trim(arr(i))
        If nameText <> "" Then
            If Not keepDict.Exists(LCase(nameText)) Then
                keepDict.Add LCase(nameText), True
            End If
        End If
    Next

    ' 少なくとも1つは存在するかチェック
    anyExists = False
    For Each ws In wb.Worksheets
        If keepDict.Exists(LCase(ws.Name)) Then
            anyExists = True
        End If
    Next

    If Not anyExists Then
        MsgBox "指定したシート名がブック内に存在しません。targetSheets の設定を確認してください。", vbCritical, "エラー"
        wb.Close False
        xl.Quit
        WScript.Quit
    End If

    ' 残さないシートを削除（後ろから順に）
    For i = wb.Worksheets.Count To 1 Step -1
        Set ws = wb.Worksheets(i)
        If Not keepDict.Exists(LCase(ws.Name)) Then
            ws.Delete
        End If
    Next
End If


' --- 同じフォルダに、必ず .xlsx（マクロなし）で保存 ---
folderPath = fso.GetParentFolderName(resolvedPath)
baseName   = fso.GetBaseName(resolvedPath)

newName = "値貼り付け_" & baseName & ".xlsx"
newPath = fso.BuildPath(folderPath, newName)

wb.SaveAs newPath, 51   ' 51 = xlOpenXMLWorkbook（マクロなし .xlsx）
If Err.Number <> 0 Then
    MsgBox "保存中にエラーが発生しました。原因: " & Err.Description, vbCritical, "エラー"
    wb.Close False
    xl.Quit
    WScript.Quit
End If

' --- 後処理 ---
wb.Close False
xl.Quit

' --- 完了メッセージ ---
MsgBox "元ファイル: " & resolvedPath & vbCrLf & "値貼り付け後のファイルを次の名前で保存しました。" & vbCrLf & newPath, vbInformation, "完了"


'================ 共分散（母分散） =========================
Public Function CovMatrix(data As Range) As Variant
    Dim n As Long, m As Long, i As Long, j As Long
    n = data.Rows.Count
    m = data.Columns.Count
    Dim arr As Variant: arr = data.Value
    Dim cov() As Double
    ReDim cov(1 To m, 1 To m)
    Dim avg_i As Double, avg_j As Double, s As Double, t As Long
    For i = 1 To m
        avg_i = Application.WorksheetFunction.Average(Application.Index(arr, 0, i))
        For j = 1 To m
            avg_j = Application.WorksheetFunction.Average(Application.Index(arr, 0, j))
            s = 0#
            For t = 1 To n
                s = s + (arr(t, i) - avg_i) * (arr(t, j) - avg_j)
            Next t
            cov(i, j) = s / n  '標本なら / (n-1)
        Next j
    Next i
    CovMatrix = cov
End Function

'================ 共通ヘルパ ===============================
Private Function Ensure2D(ByVal V As Variant) As Variant
    If TypeName(V) = "Range" Then
        Ensure2D = V.Value2
    ElseIf IsArray(V) Then
        Dim l1 As Long, u2 As Long
        On Error Resume Next
        l1 = LBound(V, 1): u2 = UBound(V, 2)
        If Err.Number <> 0 Then
            Err.Clear
            Dim L As Long, U As Long, i As Long
            L = LBound(V): U = UBound(V)
            Dim A() As Variant: ReDim A(1 To U - L + 1, 1 To 1)
            For i = L To U: A(i - L + 1, 1) = V(i): Next
            Ensure2D = A
        Else
            Ensure2D = V
        End If
        On Error GoTo 0
    Else
        Dim a1(1 To 1, 1 To 1) As Variant
        a1(1, 1) = V
        Ensure2D = a1
    End If
End Function

Private Function ToDoubleVectorV(col2D As Variant) As Variant
    Dim rL As Long, rU As Long, i As Long
    rL = LBound(col2D, 1): rU = UBound(col2D, 1)
    Dim V() As Double: ReDim V(1 To rU - rL + 1)
    For i = rL To rU
        If IsError(col2D(i, 1)) Or IsEmpty(col2D(i, 1)) Or Not IsNumeric(col2D(i, 1)) Then
            V(i - rL + 1) = 0#
        Else
            V(i - rL + 1) = CDbl(col2D(i, 1))
        End If
    Next
    ToDoubleVectorV = V
End Function

Private Function ToDoubleMatrixV(mat2D As Variant) As Variant
    Dim rL As Long, rU As Long, cL As Long, cU As Long, i As Long, j As Long
    rL = LBound(mat2D, 1): rU = UBound(mat2D, 1)
    cL = LBound(mat2D, 2): cU = UBound(mat2D, 2)
    Dim m() As Double: ReDim m(1 To rU - rL + 1, 1 To cU - cL + 1)
    For i = rL To rU
        For j = cL To cU
            If IsError(mat2D(i, j)) Or IsEmpty(mat2D(i, j)) Or Not IsNumeric(mat2D(i, j)) Then
                m(i - rL + 1, j - cL + 1) = 0#
            Else
                m(i - rL + 1, j - cL + 1) = CDbl(mat2D(i, j))
            End If
        Next j
    Next i
    ToDoubleMatrixV = m
End Function

Private Function MatVecV(m As Variant, V As Variant) As Variant
    Dim n As Long, i As Long, j As Long
    n = UBound(V)
    Dim res() As Double: ReDim res(1 To n)
    For i = 1 To n
        Dim s As Double: s = 0#
        For j = 1 To n
            s = s + m(i, j) * V(j)
        Next j
        res(i) = s
    Next i
    MatVecV = res
End Function

Private Function MaxDiagV(Mtx As Variant) As Double
    Dim n As Long, i As Long, maxVal As Double
    n = UBound(Mtx, 1)
    maxVal = Mtx(1, 1)
    For i = 2 To n
        If Mtx(i, i) > maxVal Then maxVal = Mtx(i, i)
    Next
    MaxDiagV = maxVal
End Function

Private Function VMax(A As Double, b As Double) As Double
    If A > b Then VMax = A Else VMax = b
End Function

Private Function ProjectCappedSimplexV(V As Variant, L As Variant, U As Variant) As Variant
    Dim n As Long: n = UBound(V)
    Dim w() As Double: ReDim w(1 To n)

    Dim lo As Double, hi As Double, mid As Double, s As Double
    Dim i As Long, z As Double
    lo = -1000000000000#: hi = 1000000000000#

    For i = 1 To n
        If V(i) - U(i) > lo Then lo = V(i) - U(i)
        If V(i) - L(i) < hi Then hi = V(i) - L(i)
    Next

    Dim it As Long
    For it = 1 To 60
        mid = 0.5 * (lo + hi)
        s = 0#
        For i = 1 To n
            z = V(i) - mid
            If z < L(i) Then
                z = L(i)
            ElseIf z > U(i) Then
                z = U(i)
            End If
            s = s + z
        Next
        If s > 1# Then
            lo = mid
        Else
            hi = mid
        End If
    Next

    For i = 1 To n
        z = V(i) - hi
        If z < L(i) Then
            z = L(i)
        ElseIf z > U(i) Then
            z = U(i)
        End If
        w(i) = z
    Next
    ProjectCappedSimplexV = w
End Function

Option Explicit

'=== コレスキー（下三角）分解: A=LL'。失敗時 Falseを返す ===
Private Function CholeskyDecomp(A As Variant, L As Variant) As Boolean
    Dim n As Long: n = UBound(A, 1)
    Dim i As Long, j As Long, k As Long
    Dim s As Double
    ReDim L(1 To n, 1 To n)
    On Error GoTo Fail
    For i = 1 To n
        For j = 1 To i
            s = 0#
            For k = 1 To j - 1
                s = s + L(i, k) * L(j, k)
            Next
            If i = j Then
                s = A(i, i) - s
                If s <= 0# Then CholeskyDecomp = False: Exit Function
                L(i, j) = Sqr(s)
            Else
                L(i, j) = (A(i, j) - s) / L(j, j)
            End If
        Next
    Next
    CholeskyDecomp = True
    Exit Function
Fail:
    CholeskyDecomp = False
End Function

'=== コレスキーで Ax=b を解く（前進・後退代入） ===
Private Function CholeskySolve(A As Variant, b As Variant) As Variant
    Dim n As Long: n = UBound(A, 1)
    Dim L As Variant, y() As Double, x() As Double
    Dim i As Long, k As Long, s As Double
    If Not CholeskyDecomp(A, L) Then Err.Raise 5, , "Cholesky失敗（半正定値ではない）"
    ReDim y(1 To n)
    ' 前進代入: L y = b
    For i = 1 To n
        s = b(i)
        For k = 1 To i - 1: s = s - L(i, k) * y(k): Next
        y(i) = s / L(i, i)
    Next
    ' 後退代入: L' x = y
    ReDim x(1 To n)
    For i = n To 1 Step -1
        s = y(i)
        For k = i + 1 To n: s = s - L(k, i) * x(k): Next
        x(i) = s / L(i, i)
    Next
    CholeskySolve = x
End Function

'=== {w | sum w = target, L<=w<=U} への射影（二分探索） ===
Private Sub ProjectBoxSimplexArr(w() As Double, L() As Double, U() As Double, ByVal target As Double)
    Dim n As Long: n = UBound(w)
    Dim i As Long, lo As Double, hi As Double, mid As Double, s As Double, z As Double
    lo = -1000000000000#: hi = 1000000000000#
    For i = 1 To n
        If w(i) - U(i) > lo Then lo = w(i) - U(i)
        If w(i) - L(i) < hi Then hi = w(i) - L(i)
    Next
    Dim it As Long
    For it = 1 To 60
        mid = 0.5 * (lo + hi)
        s = 0#
        For i = 1 To n
            z = w(i) - mid
            If z < L(i) Then
                z = L(i)
            ElseIf z > U(i) Then
                z = U(i)
            End If
            s = s + z
        Next
        If s > target Then lo = mid Else hi = mid
    Next
    For i = 1 To n
        z = w(i) - hi
        If z < L(i) Then
            z = L(i)
        ElseIf z > U(i) Then
            z = U(i)
        End If
        w(i) = z
    Next i
End Sub

'=== 厳密解（等式+上下限）: 逆行列/ワークシート関数 不使用／横ベクトル返し ===
' 使い方: =GMV_BOUNDED_EXACT(CovMatrix(OFFSET($X$2,0,0,125,6)), AN5:AN10, AM5:AM10)
Public Function GMV_BOUNDED_EXACT( _
    ByVal covInput As Variant, _
    ByVal L As Variant, _
    ByVal U As Variant, _
    Optional ByVal ridge As Double = 0.0000000001, _
    Optional ByVal tol As Double = 0.000000000001, _
    Optional ByVal maxIter As Long = 200 _
) As Variant
    On Error GoTo Fail

    '--- Σ 受取（Range/配列OK） ---
    Dim V As Variant
    If TypeName(covInput) = "Range" Then
        V = covInput.Value2
    Else
        V = covInput
    End If
    Dim n As Long, m As Long, i As Long, j As Long
    n = UBound(V, 1): m = UBound(V, 2)
    If n <> m Then Err.Raise 5, , "共分散は正方行列が必要です"

    Dim Sigma() As Double: ReDim Sigma(1 To n, 1 To n)
    For i = 1 To n
        For j = 1 To n
            Sigma(i, j) = CDbl(V(i, j))
        Next
    Next
    If ridge > 0# Then For i = 1 To n: Sigma(i, i) = Sigma(i, i) + ridge: Next

    '--- L/U 受取（Range/配列OK, 縦ベクトル想定） ---
    Dim LV As Variant, UV As Variant
    LV = IIf(TypeName(L) = "Range", L.Value2, L)
    UV = IIf(TypeName(U) = "Range", U.Value2, U)
    Dim Lb() As Double, Ub() As Double
    ReDim Lb(1 To n): ReDim Ub(1 To n)
    For i = 1 To n
        Lb(i) = CDbl(LV(i, 1))
        Ub(i) = CDbl(UV(i, 1))
    Next

    '--- 可行性チェック ---
    Dim sumL As Double, sumU As Double
    For i = 1 To n: sumL = sumL + Lb(i): sumU = sumU + Ub(i): Next
    If sumL > 1# + 0.000000000001 Or sumU < 1# - 0.000000000001 Then Err.Raise 5, , "不可行: SUM(L)?1?SUM(U)"

    '--- 初期点: 均等→射影 ---
    Dim w() As Double: ReDim w(1 To n)
    For i = 1 To n: w(i) = 1# / n: Next
    ProjectBoxSimplexArr w, Lb, Ub, 1#

    '--- アクティブセット ---
    Dim isB() As Boolean: ReDim isB(1 To n)
    For i = 1 To n
        If Abs(w(i) - Lb(i)) < 10 * tol Or Abs(w(i) - Ub(i)) < 10 * tol Then isB(i) = True
    Next

    Dim iter As Long
    For iter = 1 To maxIter
        Dim sumFixed As Double: sumFixed = 0#
        Dim cntF As Long: cntF = 0
        For i = 1 To n
            If isB(i) Then sumFixed = sumFixed + w(i) Else cntF = cntF + 1
        Next
        If cntF = 0 Then Exit For
        Dim targetSum As Double: targetSum = 1# - sumFixed

        ' 自由集合インデックス
        Dim F() As Long, idx As Long
        ReDim F(1 To cntF): idx = 0
        For i = 1 To n
            If Not isB(i) Then idx = idx + 1: F(idx) = i
        Next

        ' FF と 1_F を用意
        Dim FF() As Double: ReDim FF(1 To cntF, 1 To cntF)
        Dim oneF() As Double: ReDim oneF(1 To cntF)
        For i = 1 To cntF
            oneF(i) = 1#
            For j = 1 To cntF
                FF(i, j) = Sigma(F(i), F(j))
            Next
        Next

        ' y = FF^{-1} * 1_F（コレスキーで直接解く）
        Dim y As Variant: y = CholeskySolve(FF, oneF)

        ' α = target / (1_F' y)
        Dim den As Double: den = 0#
        For i = 1 To cntF: den = den + oneF(i) * y(i): Next
        If Abs(den) < 1E-18 Then Err.Raise 5, , "特異行列（ridge を上げてください）"
        Dim alpha As Double: alpha = targetSum / den

        ' w_F = α y
        For i = 1 To cntF
            w(F(i)) = alpha * y(i)
        Next

        ' 境界処理
        Dim changed As Boolean: changed = False
        For i = 1 To cntF
            Dim k As Long: k = F(i)
            If w(k) < Lb(k) - tol Then w(k) = Lb(k): isB(k) = True: changed = True
            If w(k) > Ub(k) + tol Then w(k) = Ub(k): isB(k) = True: changed = True
        Next
        If changed Then GoTo NextIter

        ' KKTチェック
        Dim Sw() As Double: ReDim Sw(1 To n)
        Dim acc As Double
        For i = 1 To n
            acc = 0#
            For j = 1 To n: acc = acc + Sigma(i, j) * w(j): Next
            Sw(i) = acc
        Next
        Dim nu As Double, cnt As Long: nu = 0#: cnt = 0
        For i = 1 To n: If Not isB(i) Then nu = nu + 2# * Sw(i): cnt = cnt + 1
        Next
        If cnt > 0 Then nu = nu / cnt Else nu = 2# * Sw(1)

        Dim violated As Long: violated = 0
        For i = 1 To n
            If isB(i) Then
                Dim gi As Double: gi = 2# * Sw(i) - nu
                If Abs(w(i) - Lb(i)) < 10 * tol Then
                    If gi < -0.0000000001 Then isB(i) = False: violated = violated + 1
                ElseIf Abs(w(i) - Ub(i)) < 10 * tol Then
                    If gi > 0.0000000001 Then isB(i) = False: violated = violated + 1
                End If
            End If
        Next
        If violated = 0 Then Exit For
NextIter:
    Next

    ' 合計=1 に微調整
    Dim sumW As Double: sumW = 0#
    For i = 1 To n: sumW = sumW + w(i): Next
    Dim delta As Double: delta = 1# - sumW
    For i = 1 To n
        If w(i) > Lb(i) + 10 * tol And w(i) < Ub(i) - 10 * tol Then
            w(i) = w(i) + delta
            Exit For
        End If
    Next

    ' 横ベクトル返し
    Dim out() As Variant: ReDim out(1 To 1, 1 To n)
    For i = 1 To n: out(1, i) = w(i): Next
    GMV_BOUNDED_EXACT = out
    Exit Function

Fail:
    GMV_BOUNDED_EXACT = CVErr(xlErrValue)
End Function

Sub RunSolverStable()

    ' 再現性のためにマルチスレッド停止
    Application.MultiThreadedCalculation.Enabled = False

    ' 強制再計算（順序を統一）
    Application.CalculateFullRebuild

    ' 初期値を強制設定
    Range("K4:P4").Value = 1 / 6

    SolverReset
    SolverOk SetCell:="$K$36", MaxMinVal:=2, _
        ByChange:="$K$4:$P$4"

    ' 制約
    SolverAdd CellRef:="$K$4:$P$4", Relation:=3, FormulaText:=1
    SolverAdd CellRef:="$K$4:$P$4", Relation:=1, FormulaText:="0"

    ' Solver オプションを明示指定
    SolverOptions Precision:=1E-12, Convergence:=1E-12, _
        MaxTime:=999, MaxIterations:=2000, _
        Scaling:=True, AssumeLinear:=False, StepThru:=False

    SolverSolve UserFinish:=True

    ' マルチスレッドを元に戻す
    Application.MultiThreadedCalculation.Enabled = True

End Sub


</code></pre>pre

</body>
</html>
